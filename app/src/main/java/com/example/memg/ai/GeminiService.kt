package com.example.memg.ai

import android.content.Context
import android.net.Uri
import com.google.genai.Client
import com.google.genai.types.Content
import com.google.genai.types.GenerateContentConfig
import com.google.genai.types.HarmBlockThreshold
import com.google.genai.types.HarmCategory
import com.google.genai.types.Part
import com.google.genai.types.SafetySetting
import com.google.genai.types.Tool
import com.google.genai.types.ThinkingConfig
import com.google.common.collect.ImmutableList
import com.google.gson.Gson
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.nio.ByteBuffer
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class GeminiService @Inject constructor(@ApplicationContext private val context: Context) {
    private var client: Client? = null
    private var apiKey: String? = null
    
    fun initialize(apiKey: String) {
        this.apiKey = apiKey
        this.client = Client.builder().apiKey(apiKey).build()
    }
    
    fun isEnabled(): Boolean {
        return client != null
    }

    fun disable() {
        client = null
        apiKey = null
    }
    
    // Process content with gemini-2.5-flash using structured output
    suspend fun processContent(
        imageUri: String? = null,
        audioUri: String? = null,
        text: String? = null,
        transcribedText: String? = null
    ): Map<String, Any> = withContext(Dispatchers.IO) {
        return@withContext try {
            val parts = mutableListOf<Part>()
            val promptBuilder = StringBuilder("You are an AI assistant for the MemGallery app. Your job is to analyze captured content and provide structured information. Always respond in JSON format with the following fields: 'title' (short, clear title), 'summary' (concise overall summary), 'tags' (array of 3-5 keywords), 'folder' (category name), 'transcription' (if audio input), 'text' (if text input), and 'image_analysis' (if image input). Missing fields should be omitted. Be concise, accurate, and contextually relevant.\n\n")

            if (imageUri != null) {
                val imageBytes = context.contentResolver.openInputStream(Uri.parse(imageUri))?.readBytes()
                if (imageBytes == null) {
                    throw IOException("Could not read image file from URI: $imageUri")
                }
                val mimeType = context.contentResolver.getType(Uri.parse(imageUri)) ?: "image/jpeg"
                parts.add(Part.fromBytes(imageBytes, mimeType))
                promptBuilder.append("Provide a detailed image_analysis of this image. ")
            }

            if (audioUri != null) {
                val audioBytes = context.contentResolver.openInputStream(Uri.parse(audioUri))?.readBytes()
                if (audioBytes == null) {
                    throw IOException("Could not read audio file from URI: $audioUri")
                }
                parts.add(Part.fromBytes(audioBytes, "audio/mp4")) // Assuming MP4 audio
                if (transcribedText != null) {
                    promptBuilder.append("Analyze this audio content based on the transcription: \"$transcribedText\". ")
                } else {
                    promptBuilder.append("Analyze this audio content. ")
                }
            }

            if (text != null) {
                parts.add(Part.fromText(text))
                promptBuilder.append("Analyze this text content: \"$text\". ")
            }

            promptBuilder.append("Provide a detailed summary, relevant tags, and suggest an appropriate folder name.")

            parts.add(0, Part.fromText(promptBuilder.toString())) // Add prompt as the first part

            val multimodalContent = com.google.genai.types.Content.fromParts(*parts.toTypedArray())

            val response = client?.models?.generateContent("gemini-2.5-flash", multimodalContent, null)

            val textResponse = response?.text() ?: ""
            parseJsonResponse(textResponse)
        } catch (e: Exception) {
            e.printStackTrace()
            mapOf(
                "title" to "Multimodal Content",
                "summary" to "This is a summary generated by AI from multimodal content",
                "tags" to listOf("multimodal", "demo", "memgallery"),
                "folder" to "Uncategorized",
                "transcription" to "",
                "text" to "",
                "image_analysis" to ""
            )
        }
    }
    
    // Parse the JSON response from the Gemini API
    private fun parseJsonResponse(responseText: String): Map<String, Any> {
        return try {
            // Clean the response text by removing markdown code block delimiters
            val cleanedResponseText = responseText
                .removePrefix("```json")
                .removeSuffix("```")
                .trim()

            // Parse the JSON response
            val gson = com.google.gson.Gson()
            val jsonObject = gson.fromJson(cleanedResponseText, java.util.HashMap::class.java) as? HashMap<String, Any>
            
            val summary = jsonObject?.get("summary") as? String ?: "Processed content"
            val tags = (jsonObject?.get("tags") as? List<*>)?.filterIsInstance<String>() ?: listOf("general")
            val folder = jsonObject?.get("folder") as? String ?: "Uncategorized"
            val title = jsonObject?.get("title") as? String ?: summary.take(50) // Use summary as fallback for title
            val transcription = jsonObject?.get("transcription") as? String
            val text = jsonObject?.get("text") as? String
            val imageAnalysis = jsonObject?.get("image_analysis") as? String
            
            mapOf(
                "title" to title,
                "summary" to summary,
                "tags" to tags,
                "folder" to folder,
                "transcription" to (transcription ?: ""),
                "text" to (text ?: ""),
                "image_analysis" to (imageAnalysis ?: "")
            )
        } catch (e: Exception) {
            e.printStackTrace()
            // Return a basic structure if parsing fails
            mapOf(
                "summary" to responseText.substring(0, minOf(responseText.length, 100)) + "...",
                "tags" to listOf("general"),
                "folder" to "Uncategorized"
            )
        }
    }
}
